<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Trick-Taking — Minimal UI (Trump Picker)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;800&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0d1215; --felt1:#176735; --felt2:#0f3f21; --panel:#12171c; --line:#27323e;
    --ink:#e9f3ef; --muted:#a4b6b0; --accent:#48e291; --accentInk:#072b18;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0}
  body{background:var(--bg); color:var(--ink); font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; overflow:hidden}

  /* Root layout: full screen, no scroll */
  .root {
    height:100vh; width:100vw; display:grid; gap:10px;
    grid-template-columns: 1fr 320px;
    grid-template-rows: 72px 1fr 160px;
    grid-template-areas:
      "title  side"
      "table  side"
      "p1hand side";
    padding:10px; max-width:1400px; margin:0 auto;
  }

  header {
    grid-area:title; display:flex; align-items:center; justify-content:center;
    font-weight:800; font-size:20px;
  }

  .side { grid-area:side; display:flex; flex-direction:column; gap:10px; }
  .card { background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:12px; }
  .controls { display:flex; flex-direction:column; gap:12px }
  .row { display:flex; align-items:center; justify-content:space-between; gap:10px; }
  .btn { appearance:none; border:0; border-radius:12px; padding:10px 14px; font-weight:800; cursor:pointer; }
  .btn.primary { background:var(--accent); color:var(--accentInk); }
  .btn.secondary { background:#22303b; color:#d7ece5; border:1px solid var(--line); }
  .badge { background:#0f151a; border:1px solid var(--line); padding:8px 12px; border-radius:999px; font-weight:800; display:inline-flex; gap:8px; align-items:center; }

  /* Table */
  .table {
    grid-area:table; background:linear-gradient(180deg,var(--felt1),var(--felt2)); border-radius:16px;
    border:1px solid #0c2c19; position:relative; display:grid; place-items:center;
  }
  .arena {
    width:min(960px, 92vw); height:min(520px, 56vh);
    position:relative; display:grid;
    grid-template-columns: 140px 1fr 140px;
    grid-template-rows: 110px 1fr 110px;
    align-items:center; justify-items:center;
  }

  .seat { display:flex; flex-direction:column; align-items:center; gap:6px; }
  .seat .name { font-size:12px; color:var(--muted) }

  .p3 { grid-column:2; grid-row:1; }
  .p2 { grid-column:3; grid-row:2; }
  .p4 { grid-column:1; grid-row:2; }
  .center { grid-column:2; grid-row:2; position:relative; width:280px; height:220px; }

  .slot { width:84px; height:116px; border-radius:8px; overflow:hidden; display:flex; align-items:center; justify-content:center; background:transparent; }
  .slot img { width:100%; height:100%; object-fit:cover; display:block; }

  .slot.p3 { position:absolute; top:0; left:50%; transform:translate(-50%, 0); }
  .slot.p1 { position:absolute; bottom:0; left:50%; transform:translate(-50%, 0); }
  .slot.p2 { position:absolute; top:50%; right:0; transform:translate(0, -50%); }
  .slot.p4 { position:absolute; top:50%; left:0; transform:translate(0, -50%); }

  .note { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); font-size:12px; color:#cfe8df; opacity:.9; }

  /* Hands */
  .p1hand { grid-area:p1hand; display:flex; align-items:center; justify-content:center; overflow:hidden; }
  .hand-row { display:flex; gap:8px; padding:8px 10px; overflow:hidden; max-width:95vw; }

  .card-img { width:64px; height:90px; object-fit:cover; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,.45); cursor:pointer; transition:.16s transform; }
  .card-img:hover { transform:translateY(-4px); }
  .card-img:active { transform:translateY(-8px); }

  .count { font-size:12px; color:#d0ded8; opacity:.9 }

  .lasttrick { display:grid; grid-template-columns: repeat(4, 60px); gap:8px; place-items:center; }
  .mini { width:54px; height:76px; border-radius:6px; overflow:hidden; }
  .mini img { width:100%; height:100%; object-fit:cover; display:block; }

  .fly { position:fixed; z-index:9999; pointer-events:none; width:64px; height:90px; border-radius:8px; box-shadow:0 12px 32px rgba(0,0,0,.6);
         transition:transform .5s cubic-bezier(.2,.9,.3,1), opacity .35s; }

  h3 { margin:0 0 8px 0; font-size:13px; color:var(--muted); letter-spacing:.3px; text-transform:uppercase; }

  /* Trump modal */
  .modal {
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.45); z-index:50;
  }
  .modal .sheet { background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:16px; width:min(520px, 92vw); }
  .suits { display:flex; flex-wrap:wrap; gap:8px; justify-content:center; margin-top:8px; }
  .suitbtn { padding:10px 12px; border-radius:10px; border:1px solid var(--line); background:#22303b; color:#d7ece5; font-weight:800; cursor:pointer; }
  .suitbtn.primary { background:var(--accent); color:var(--accentInk); border:0; }
</style>
</head>
<body>
  <div class="root">
    <header>Trick-Taking — Minimal UI</header>

    <!-- TABLE -->
    <div class="table card">
      <div class="arena">
        <!-- Top: P3 -->
        <div class="seat p3">
          <div class="name">P3</div>
          <div class="count" id="count-P3">(0 cards)</div>
        </div>

        <!-- Left: P4 -->
        <div class="seat p4">
          <div class="name">P4</div>
          <div class="count" id="count-P4">(0 cards)</div>
        </div>

        <!-- Right: P2 -->
        <div class="seat p2">
          <div class="name">P2</div>
          <div class="count" id="count-P2">(0 cards)</div>
        </div>

        <!-- Center: current trick -->
        <div class="center" id="center">
          <div class="slot p3" id="slot-P3"></div>
          <div class="slot p2" id="slot-P2"></div>
          <div class="slot p1" id="slot-P1"></div>
          <div class="slot p4" id="slot-P4"></div>
          <div class="note" id="center-note">Click “Start Match” to deal 5 cards and choose trump</div>
        </div>
      </div>
    </div>

    <!-- P1 hand (bottom) -->
    <div class="p1hand card">
      <div class="hand-row" id="you-hand"></div>
    </div>

    <!-- RIGHT SIDE -->
    <aside class="side">
      <div class="card controls">
        <div class="row"><h3>Controls</h3><button id="btn-start" class="btn primary">Start Match</button></div>
        <div class="row"><span class="badge">Trump: <strong id="ui-trump" style="margin-left:6px">—</strong></span></div>
        <div class="row"><span class="badge">Pool: <strong id="ui-pool" style="margin-left:6px">0</strong></span></div>
        <div class="row"><span class="badge">T1 (P1+P3): <strong id="ui-t1" style="margin-left:6px">0</strong></span></div>
        <div class="row"><span class="badge">T2 (P2+P4): <strong id="ui-t2" style="margin-left:6px">0</strong></span></div>
        <div class="row"><span class="badge">Starter: <strong id="ui-starter" style="margin-left:6px">—</strong></span></div>
        <div class="row"><span class="badge">Trick #: <strong id="ui-trick" style="margin-left:6px">0</strong></span></div>
      </div>

      <div class="card">
        <h3>Last Trick</h3>
        <div class="lasttrick" id="last-trick">
          <div class="mini" id="lt-P3"></div>
          <div class="mini" id="lt-P2"></div>
          <div class="mini" id="lt-P1"></div>
          <div class="mini" id="lt-P4"></div>
        </div>
      </div>
    </aside>
  </div>

  <!-- Trump Picker Modal -->
  <div class="modal" id="trump-modal">
    <div class="sheet">
      <h3>Choose Trump (or pick Random)</h3>
      <div class="suits">
        <button class="suitbtn" data-suit="Spades">Spades ♠</button>
        <button class="suitbtn" data-suit="Hearts">Hearts ♥</button>
        <button class="suitbtn" data-suit="Diamonds">Diamonds ♦</button>
        <button class="suitbtn" data-suit="Clubs">Clubs ♣</button>
        <button class="suitbtn primary" data-suit="__RANDOM__">Random</button>
      </div>
      <div class="row" style="margin-top:10px; justify-content:center; color:var(--muted); font-size:12px;">
        You’ll see 5 cards first. After choosing trump, everyone gets 13 and play begins.
      </div>
    </div>
  </div>

<script>
/* ========= Cards asset helpers ========= */
const SUITS = ["Spades","Hearts","Diamonds","Clubs"];
const SUIT_SYMBOL = {Spades:"♠",Hearts:"♥",Diamonds:"♦",Clubs:"♣"};
const RANKS = [2,3,4,5,6,7,8,9,10,11,12,13,14];
const RANK_LABEL = {11:"J",12:"Q",13:"K",14:"A"};
const PLAYERS = ["P1","P4","P3","P2"]; // CCW turn order
const TEAM_OF = {P1:1,P3:1,P2:2,P4:2};

const rankToName = {11:'jack',12:'queen',13:'king',14:'ace'};
const suitToFile = {Spades:'spades',Hearts:'hearts',Diamonds:'diamonds',Clubs:'clubs'};
function rankLabel(r){ return RANK_LABEL[r] || String(r); }
function cardStr(c){ return `${rankLabel(c.r)}${SUIT_SYMBOL[c.s]}`; }
function rankToFile(r){ return rankToName[r] || String(r); }
function getCardFileName(card){
  return `PNG-cards-1.3/${rankToFile(card.r)}_of_${suitToFile[card.s]}.png`;
}

/* ========= Engine (same logic, with manual/random trump) ========= */
function createDeck(){ const d=[]; for(const s of SUITS) for(const r of RANKS) d.push({r,s}); return d; }
function shuffle(a,rng=Math){ for(let i=a.length-1;i>0;i--){ const j=Math.floor((rng.random?rng.random():Math.random())*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function strength(card, leadSuit, trump){ return [(trump && card.s===trump)?1:0, (leadSuit && card.s===leadSuit)?1:0, card.r]; }
function cmp(a,b){ for(let i=0;i<3;i++){ if(a[i]>b[i]) return 1; if(a[i]<b[i]) return -1; } return 0; }
function currentWinner(played, trump){
  if(!played.length) return null;
  const lead = played[0].card.s;
  let best = played[0], bestScore = strength(best.card, lead, trump);
  for(const p of played.slice(1)){ const sc = strength(p.card, lead, trump); if(cmp(sc,bestScore)>0){ best=p; bestScore=sc; } }
  return best;
}

class GameCore {
  constructor(seed=null, playersMode=null){
    this.rng = seed ? this._seededRandom(seed) : Math;
    this.playersMode = {P1:'human',P2:'bot',P3:'bot',P4:'bot'};
    if(playersMode) Object.assign(this.playersMode, playersMode);
    this.reset();
  }
  _seededRandom(seed){ let t=seed>>>0; return { random(){ t+=0x6D2B79F5; let r=Math.imul(t^t>>>15,1|t); r^=r+Math.imul(r^r>>>7,61|r); return ((r^r>>>14)>>>0)/4294967296; } }; }
  reset(){ this.matchPoints={1:0,2:0}; this.resetForNewSeries(); }
  resetForNewSeries(){ this.chooserIndex=0; this.startNewMatch_Deal5(); }

  startNewMatch_Deal5(){
    this.deck=createDeck(); shuffle(this.deck,this.rng);
    this.hands={P1:[],P2:[],P3:[],P4:[]};
    for(let i=0;i<5;i++) for(const p of PLAYERS) this.hands[p].push(this.deck.pop());
    for(const p of PLAYERS) this.hands[p]=this._sortHand(this.hands[p]);
    this.trump=null; this.chosenRandom=false; this.unclaimedPool=0;
    this.teamTricks={1:0,2:0}; this.playerTricks={P1:0,P2:0,P3:0,P4:0};
    this.matchLog=[]; this.lastTrickWinner=null; this.consecutiveCount=0;
    this.trickNumber=0; this.currentTrick=[]; this.starterIndex=this.chooserIndex;
    this.lastCompletedTrick=[]; this.seenCards=[]; this.pendingResolve=false;
  }

  // Complete dealing to 13 & set trump based on RANDOM up-card rule
  chooseTrumpRandom(){
    this.chosenRandom=true;
    const chooser=PLAYERS[this.chooserIndex];
    while(Object.values(this.hands).some(h=>h.length<13)){
      for(const p of PLAYERS){
        if(this.hands[p].length<13){
          const c=this.deck.pop(); this.hands[p].push(c);
          if(p===chooser && this.hands[p].length===13){ this.trump=c.s; }
        }
      }
    }
    for(const p of PLAYERS) this.hands[p]=this._sortHand(this.hands[p]);
    this.starterIndex=this.chooserIndex;
    return this.getStateView();
  }

  // Complete dealing to 13 & set trump to chosen suit
  chooseTrumpManual(suit){
    this.trump = suit;
    while(Object.values(this.hands).some(h=>h.length<13)){
      for(const p of PLAYERS){
        if(this.hands[p].length<13){
          const c=this.deck.pop(); this.hands[p].push(c);
        }
      }
    }
    for(const p of PLAYERS) this.hands[p]=this._sortHand(this.hands[p]);
    this.starterIndex=this.chooserIndex;
    return this.getStateView();
  }

  _sortHand(hand){ const o={Spades:0,Hearts:1,Diamonds:2,Clubs:3}; return hand.slice().sort((a,b)=> o[a.s]-o[b.s] || b.r-a.r); }
  chooserIsHuman(){ return this.chooserIndex===0; }
  getStateView(forPlayer=null){
    const hv={}; for(const p of PLAYERS){ hv[p]= (forPlayer==null||forPlayer===p) ? this.hands[p].slice() : {count:this.hands[p].length}; }
    return {
      trump:this.trump, chooser:PLAYERS[this.chooserIndex], starter:PLAYERS[this.starterIndex],
      trickNumber:this.trickNumber+1, unclaimedPool:this.unclaimedPool, teamTricks:{...this.teamTricks},
      playerTricks:{...this.playerTricks}, currentTrick:this.currentTrick.map(x=>({player:x.pid,card:{...x.card}})),
      lastCompletedTrick:this.lastCompletedTrick.map(x=>({player:x[0],card:{...x[1]}})),
      lastTrickWinner:this.lastTrickWinner, hands:hv, isOver:this.isMatchOver(), tricksRemaining:this.tricksRemaining()
    };
  }
  isMatchOver(){ return PLAYERS.every(p=>this.hands[p].length===0); }
  tricksRemaining(){ return 13-this.trickNumber; }
  _whoseTurn(){ const starter=this.starterIndex; const offset=this.currentTrick.length%4; return PLAYERS[(starter+offset)%4]; }

  getValidInvalid(playerId){
    const hand=this.hands[playerId];
    if(this.currentTrick.length===0) return {valid:this._sortHand(hand), invalid:[]};
    const lead=this.currentTrick[0].card.s;
    const follow=hand.filter(c=>c.s===lead);
    const valid=follow.length?this._sortHand(follow):this._sortHand(hand.slice());
    const invalid=hand.filter(c=>!valid.some(v=>v.r===c.r && v.s===c.s));
    return {valid:[...valid], invalid:this._sortHand(invalid)};
  }

  playCard(playerId, card){
    if(this._whoseTurn()!==playerId) throw new Error("Not player's turn");
    const idx=this.hands[playerId].findIndex(c=>c.r===card.r && c.s===card.s);
    if(idx===-1) throw new Error("Card not in hand");
    if(this.currentTrick.length){
      const lead=this.currentTrick[0].card.s;
      if(this.hands[playerId].some(c=>c.s===lead) && card.s!==lead) throw new Error("Must follow suit");
    }
    this.hands[playerId].splice(idx,1);
    this.currentTrick.push({idx:PLAYERS.indexOf(playerId), pid:playerId, card:card});
    const events=[{type:'play', player:playerId, card:{...card}}];
    if(this.currentTrick.length===4){ events.push(...this._resolveTrick()); }
    return {events, state:this.getStateView()};
  }

  _resolveTrick(){
    const winnerObj=currentWinner(this.currentTrick.map(x=>({idx:x.idx,pid:x.pid,card:x.card})), this.trump);
    const winnerIdx=winnerObj.idx; const winnerName=PLAYERS[winnerIdx]; const winningCard=winnerObj.card;
    this.lastCompletedTrick=this.currentTrick.map(x=> [x.pid, {...x.card}] );
    this.currentTrick=[]; const prevWinner=this.lastTrickWinner; this.lastTrickWinner=winnerName; this.starterIndex=winnerIdx;
    this.trickNumber+=1; this.unclaimedPool+=1; this.consecutiveCount = (prevWinner===winnerName) ? this.consecutiveCount+1 : 1;
    const events=[];
    if(this.consecutiveCount>=2){
      const team=TEAM_OF[winnerName], captured=this.unclaimedPool;
      this.teamTricks[team]+=captured; this.playerTricks[winnerName]+=captured;
      this.unclaimedPool=0; this.consecutiveCount=0;
      events.push({type:'pool_captured', by_player:winnerName, team, amount:captured});
    }
    events.push({type:'trick_complete', trick_number:this.trickNumber, winner:winnerName, winning_card:{...winningCard}});
    if(this.isMatchOver()){ const res=this.finalizeMatch(); events.push({type:'match_end', result:res}); }
    return events;
  }

  finalizeMatch(){
    if(this.unclaimedPool>0 && this.lastTrickWinner){
      const t=TEAM_OF[this.lastTrickWinner];
      this.teamTricks[t]+=this.unclaimedPool; this.playerTricks[this.lastTrickWinner]+=this.unclaimedPool; this.unclaimedPool=0;
    }
    return {team_tricks:{...this.teamTricks}, player_tricks:{...this.playerTricks}, trump:this.trump, last_trick_winner:this.lastTrickWinner};
  }

  _validFor(pid){
    const h=this.hands[pid];
    if(this.currentTrick.length===0) return this._sortHand(h);
    const lead=this.currentTrick[0].card.s; const same=h.filter(c=>c.s===lead);
    return same.length?this._sortHand(same):this._sortHand(h.slice());
  }
  _minBy(a,f){ return a.reduce((x,y)=> f(y)<f(x)?y:x ); }
  _maxBy(a,f){ return a.reduce((x,y)=> f(y)>f(x)?y:x ); }
  _botChooseCard(pid){
    const valid=this._validFor(pid);
    if(this.currentTrick.length===0){ // lead low-ish
      const nonTr=valid.filter(c=>c.s!==this.trump);
      return nonTr.length?this._minBy(nonTr,c=>c.r):this._minBy(valid,c=>c.r);
    } else {
      const lead=this.currentTrick[0].card.s;
      const cur=currentWinner(this.currentTrick.map(x=>({idx:x.idx,pid:x.pid,card:x.card})), this.trump);
      const beat=valid.filter(c=> {
        const a=strength(c, lead, this.trump), b=strength(cur.card, lead, this.trump);
        return cmp(a,b)>0;
      });
      return beat.length?this._minBy(beat,c=>c.r):this._minBy(valid,c=>c.r);
    }
  }
  _applyPlay(pid, ct){
    const idx=this.hands[pid].findIndex(c=>c.r===ct.r && c.s===ct.s);
    if(idx===-1) throw new Error("card missing in _applyPlay");
    this.hands[pid].splice(idx,1);
    this.currentTrick.push({idx:PLAYERS.indexOf(pid), pid, card:ct});
    const events=[{type:'play', player:pid, card:{...ct}}];
    if(this.currentTrick.length===4){ events.push(...this._resolveTrick()); }
    return events;
  }
}

/* ========= UI wiring ========= */
const ui = {
  youHand: document.getElementById('you-hand'),
  slots: { P1: document.getElementById('slot-P1'), P2: document.getElementById('slot-P2'),
           P3: document.getElementById('slot-P3'), P4: document.getElementById('slot-P4') },
  counts: { P2: document.getElementById('count-P2'), P3: document.getElementById('count-P3'), P4: document.getElementById('count-P4') },
  lastTrick: { P1: document.getElementById('lt-P1'), P2: document.getElementById('lt-P2'),
               P3: document.getElementById('lt-P3'), P4: document.getElementById('lt-P4') },
  note: document.getElementById('center-note'),
  btnStart: document.getElementById('btn-start'),
  trumpModal: document.getElementById('trump-modal'),
  trumpButtons: null,
  info: {
    trump: document.getElementById('ui-trump'),
    pool: document.getElementById('ui-pool'),
    t1: document.getElementById('ui-t1'),
    t2: document.getElementById('ui-t2'),
    starter: document.getElementById('ui-starter'),
    trick: document.getElementById('ui-trick'),
  }
};

let game = null;
let humanLocked = true;
const BOT_DELAY_MS = 2000; // ~2 seconds between turns

function clearCurrentSlots(){ for(const k in ui.slots){ ui.slots[k].innerHTML=''; } }
function setCounts(){
  ui.counts.P2.textContent = `(${game.hands.P2.length} cards)`;
  ui.counts.P3.textContent = `(${game.hands.P3.length} cards)`;
  ui.counts.P4.textContent = `(${game.hands.P4.length} cards)`;
}
function updateInfo(){
  ui.info.trump.textContent = game.trump ? `${game.trump} ${SUIT_SYMBOL[game.trump]}` : '—';
  ui.info.pool.textContent = String(game.unclaimedPool);
  ui.info.t1.textContent = String(game.teamTricks[1]);
  ui.info.t2.textContent = String(game.teamTricks[2]);
  ui.info.starter.textContent = PLAYERS[game.starterIndex] || '—';
  ui.info.trick.textContent = String(game.trickNumber+1);
}
function renderYourHand(){
  ui.youHand.innerHTML='';
  const hand = game.hands.P1 || [];
  const {valid} = game.getValidInvalid('P1');
  const validKeys = new Set(valid.map(c=>`${c.r}-${c.s}`));
  hand.forEach((c)=>{
    const img = document.createElement('img');
    img.src = getCardFileName(c); img.alt = cardStr(c);
    img.className = 'card-img'; img.draggable = false;
    const key = `${c.r}-${c.s}`; const isValid = validKeys.has(key);
    if(!isValid){ img.style.opacity = .45; img.style.cursor='not-allowed'; }
    img.addEventListener('click', ()=>{
      if(!isValid || humanLocked) return;
      humanLocked = true;
      const sourceRect = img.getBoundingClientRect();
      const fly = img.cloneNode(true); fly.className = 'fly';
      document.body.appendChild(fly);
      fly.style.left = sourceRect.left+'px'; fly.style.top = sourceRect.top+'px';
      try {
        const res = game.playCard('P1', c);
        img.remove();
        const target = ui.slots['P1'].getBoundingClientRect();
        const dx = target.left + (target.width - sourceRect.width)/2 - sourceRect.left;
        const dy = target.top  + (target.height- sourceRect.height)/2 - sourceRect.top;
        fly.style.transform = `translate(${dx}px, ${dy}px) scale(${(target.width/sourceRect.width)||1})`;
        setTimeout(()=>{ fly.style.opacity='0'; setTimeout(()=> fly.remove(), 300); }, 450);
        placePlayedCard('P1', c);
        handleEvents(res.events);
        setTimeout(()=> botFlow(game.starterIndex, game.currentTrick.length), BOT_DELAY_MS);
      } catch(e){
        fly.remove(); humanLocked = false; alert(e.message);
      }
    });
    ui.youHand.appendChild(img);
  });
}
function placePlayedCard(pid, card){
  const slot = ui.slots[pid]; if(!slot) return;
  slot.innerHTML=''; const img = document.createElement('img');
  img.src = getCardFileName(card); img.alt = cardStr(card);
  slot.appendChild(img);
}
function showLastTrick(){
  for(const p in ui.lastTrick){ ui.lastTrick[p].innerHTML=''; }
  game.lastCompletedTrick.forEach(([pid, card])=>{
    const cell = ui.lastTrick[pid]; if(cell){
      const img = document.createElement('img');
      img.src = getCardFileName(card); img.alt = cardStr(card);
      cell.appendChild(img);
    }
  });
}
function handleEvents(events){
  if(!events || !events.length) return;
  for(const e of events){
    if(e.type==='play'){
      if(e.player!=='P1'){ placePlayedCard(e.player, e.card); }
    } else if(e.type==='trick_complete'){
      setTimeout(()=>{
        showLastTrick(); clearCurrentSlots(); setCounts(); updateInfo();
      }, 400);
    } else if(e.type==='match_end'){
      updateInfo();
      setTimeout(()=>{
        alert(`Match finished.\nTeam 1: ${e.result.team_tricks[1]}\nTeam 2: ${e.result.team_tricks[2]}\nTrump: ${e.result.trump}`);
      }, 200);
    }
  }
  renderYourHand(); setCounts(); updateInfo();
}
function botFlow(starterIndex, turnOffset){
  if(game.isMatchOver()) { updateInfo(); return; }
  if(turnOffset>=4){ setTimeout(()=> beginTrick(), 600); return; }
  const idx = (starterIndex + turnOffset) % 4;
  const pid = PLAYERS[idx];
  if(pid==='P1'){ humanLocked = false; renderYourHand(); return; }
  setTimeout(()=>{
    const chosen = game._botChooseCard(pid);
    const events = game._applyPlay(pid, chosen);
    placePlayedCard(pid, chosen);
    handleEvents(events);
    botFlow(starterIndex, turnOffset+1);
  }, BOT_DELAY_MS);
}
function beginTrick(){
  if(game.isMatchOver()){ updateInfo(); return; }
  clearCurrentSlots();
  ui.note.textContent = `Trick ${game.trickNumber+1} — Starter: ${PLAYERS[game.starterIndex]}`;
  updateInfo();
  if(PLAYERS[game.starterIndex]==='P1'){ humanLocked = false; renderYourHand(); }
  else { humanLocked = true; setTimeout(()=> botFlow(game.starterIndex, 0), BOT_DELAY_MS); }
}

/* ===== Trump picker flow ===== */
function openTrumpModal(){ ui.trumpModal.style.display='flex'; }
function closeTrumpModal(){ ui.trumpModal.style.display='none'; }

function startMatch(){
  // New match: deal 5 and prompt for trump
  game = new GameCore(null, {P1:'human',P2:'bot',P3:'bot',P4:'bot'});
  ui.note.textContent = 'Choose a trump to continue';
  clearCurrentSlots();
  setCounts(); updateInfo(); renderYourHand();
  openTrumpModal();
}

function onChooseTrump(suit){
  if(suit==='__RANDOM__'){
    game.chooseTrumpRandom(); // up-card defines trump while finishing the deal
  } else {
    game.chooseTrumpManual(suit); // set chosen suit, then finish the deal
  }
  closeTrumpModal();
  ui.note.textContent = 'Play your card';
  setCounts(); updateInfo(); renderYourHand();
  // Begin first trick (starter is chooser)
  if(PLAYERS[game.starterIndex]==='P1'){ humanLocked = false; }
  else { humanLocked = true; setTimeout(()=> botFlow(game.starterIndex, 0), BOT_DELAY_MS); }
}

/* Wire up UI */
ui.btnStart.addEventListener('click', startMatch);
ui.trumpButtons = Array.from(document.querySelectorAll('.suitbtn'));
ui.trumpButtons.forEach(btn=>{
  btn.addEventListener('click', ()=> onChooseTrump(btn.dataset.suit));
});

/* Idle state (before Start) */
(function initIdle(){
  game = new GameCore(null, {P1:'human',P2:'bot',P3:'bot',P4:'bot'});
  // show the initial 5-card deal (pre-trump) just for counts/hand preview
  setCounts(); updateInfo(); renderYourHand();
})();
</script>
</body>
</html>
